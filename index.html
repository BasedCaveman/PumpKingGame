<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Crown Collector (Mobile + Instructions)</title>
  <style>
    /* Basic Reset & Layout */
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      font-family: sans-serif;
    }

    /* Game Canvas */
    #gameCanvas {
      display: block;
      margin: 0 auto;
      border: 2px solid #fff;
      background: #111; /* Plain background for MVP */
      /* We'll keep 450x800 from your last version as an example */
    }

    /* Overlay UI */
    #overlay {
      position: absolute;
      top: 0; 
      width: 100%;
      color: #fff;
      text-align: center;
      pointer-events: none;
    }
    #livesDisplay, #scoreDisplay {
      margin: 0.5em;
      font-size: 20px;
      text-shadow: 1px 1px 0 #000;
    }

    /* Game Over Screen */
    #gameOverScreen {
      display: none;
      position: absolute;
      top: 30%;
      width: 100%;
      color: #fff;
      font-size: 24px;
      text-align: center;
    }

    /* ======== Instruction Overlay ======== */
    #instructionsOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      color: #fff;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      z-index: 9999; /* above everything */
    }
    #instructionsOverlay button {
      margin-top: 1em;
      padding: 0.5em 1em;
      font-size: 16px;
      cursor: pointer;
    }

    /* ======== Mobile Controls ======== */
    /* Two buttons (left, right) at bottom corners */
    #mobileControls {
      position: absolute;
      bottom: 0;
      width: 100%;
      height: 100px; /* enough height for big buttons */
      display: flex;
      justify-content: space-between;
      pointer-events: none; /* By default, off */
    }
    .control-btn {
      width: 50%;
      background: rgba(255, 255, 255, 0.1);
      pointer-events: auto; /* re-enable click/touch on the buttons */
    }
    .control-btn:active {
      background: rgba(255, 255, 255, 0.2);
    }

    /* Some styling for text inside the control buttons (optional) */
    .control-btn span {
      color: #fff;
      font-size: 24px;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }
  </style>
</head>
<body>

<!-- Instruction Overlay -->
<div id="instructionsOverlay">
  <h1>Welcome to Crown Collector</h1>
  <p>
    Collect <strong>üëë</strong> crowns<br>
    Avoid <strong>üá∑üá∫ $MELANIA</strong>, <strong>‚ôé LIBRA</strong>, <strong>üí∏ PUMP FUN MEME's</strong><br>
    and especially dodge the <strong>üßª RUGS</strong>.<br><br>
    Survive as long as possible!
  </p>
  <button id="startGameBtn">Start Game</button>
</div>

<!-- Main Canvas -->
<canvas id="gameCanvas" width="450" height="800"></canvas>

<!-- UI Overlays -->
<div id="overlay">
  <div id="livesDisplay">Lives: 6</div>
  <div id="scoreDisplay">Score: 0</div>
</div>

<!-- Game Over Screen -->
<div id="gameOverScreen">
  <div id="gameOverMessage">RUGGED AGAIN</div>
  <div>Final Score: <span id="finalScoreValue">0</span></div>
  <div>High Score: <span id="highScoreValue">0</span></div>
  <div>Press SPACE or tap "Start Game" to play again</div>
</div>

<!-- Mobile Controls -->
<div id="mobileControls">
  <div id="leftBtn" class="control-btn">
    <span>‚¨ÖÔ∏è</span>
  </div>
  <div id="rightBtn" class="control-btn">
    <span>‚û°Ô∏è</span>
  </div>
</div>

<script>
/*  
  Crown Collector with Red Halo - Mobile + Instruction Overlay
  ============================================================

  This version:
  1. Displays instructions in an overlay (#instructionsOverlay) before starting.
  2. Adds on-screen controls (#mobileControls) for mobile:
     - #leftBtn => move left
     - #rightBtn => move right
  3. Preserves arrow key logic for desktop users.
*/

/*********************************
 * Canvas & Context
 *********************************/
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const WIDTH = canvas.width;   // 450
const HEIGHT = canvas.height; // 800

/*********************************
 * Game Variables
 *********************************/
let player = {
  x: WIDTH / 2 - 24,
  y: HEIGHT - 70,
  width: 48,
  height: 48,
  speed: 6,
  lives: 6
};

let score = 0;           
let crownsCollected = 0; 
let rugsAvoidedCount = 0;
let highScore = 0;       

try {
  highScore = parseInt(localStorage.getItem('emojiCollectorHighScore')) || 0;
} catch(e) {
  highScore = 0;
}

// Arrays for falling objects
let crowns = [];
let coins = [];
let rugs = [];
let redHalo = null; // special item

// Timers & spawn intervals
let crownSpawnInterval = 40;
let coinSpawnInterval = 80;
let rugSpawnInterval = 500;
let crownSpawnTimer = 0;
let coinSpawnTimer = 0;
let rugSpawnTimer = 0;

// Halo Mode
let haloActive = false;
let haloTimer = 0;       
let haloCrownBuffer = 0; 

/*********************************
 * Emojis
 *********************************/
const EMOJI_PLAYER_NORMAL = "üéÉ";
const EMOJI_PLAYER_HALO   = "üíÄ‚≠ï";
const EMOJI_CROWN         = "üëë";
const EMOJI_COINS_LIBRA   = "‚ôé"; 
const EMOJI_COINS_MELANIA = "üá∑üá∫";
const EMOJI_COINS_PF      = "üí∏";
const EMOJI_RUG           = "üßª";
const EMOJI_RED_HALO      = "‚≠ï";

// We'll make an array for coins
const EMOJI_COINS = [EMOJI_COINS_LIBRA, EMOJI_COINS_MELANIA, EMOJI_COINS_PF];

let playerEmoji = EMOJI_PLAYER_NORMAL;

/*********************************
 * Input (Keyboard + Mobile Touch)
 *********************************/
let keys = {};
let gameStarted = false;
let gameOver = false;

// For mobile, track states
let movingLeft = false;
let movingRight = false;

/************** KEYBOARD **************/
window.addEventListener('keydown', (e) => {
  if (gameOver && e.code === 'Space') {
    restartGame();
  }
  keys[e.code] = true;
});
window.addEventListener('keyup', (e) => {
  keys[e.code] = false;
});

/************** MOBILE TOUCH **************/
// Left Button
const leftBtn = document.getElementById('leftBtn');
leftBtn.addEventListener('touchstart', (e) => {
  e.preventDefault();
  movingLeft = true;
});
leftBtn.addEventListener('touchend', (e) => {
  e.preventDefault();
  movingLeft = false;
});

// Right Button
const rightBtn = document.getElementById('rightBtn');
rightBtn.addEventListener('touchstart', (e) => {
  e.preventDefault();
  movingRight = true;
});
rightBtn.addEventListener('touchend', (e) => {
  e.preventDefault();
  movingRight = false;
});

/*********************************
 * Initialize / Start
 *********************************/
const instructionsOverlay = document.getElementById('instructionsOverlay');
const startGameBtn = document.getElementById('startGameBtn');

startGameBtn.addEventListener('click', () => {
  instructionsOverlay.style.display = 'none';
  startGame();
});

function startGame() {
  // reset
  gameOver = false;
  player.lives = 6;
  score = 0;
  crownsCollected = 0;
  rugsAvoidedCount = 0;
  crowns = [];
  coins = [];
  rugs = [];
  redHalo = null;
  haloActive = false;
  haloTimer = 0;
  haloCrownBuffer = 0;
  playerEmoji = EMOJI_PLAYER_NORMAL;
  
  document.getElementById('gameOverScreen').style.display = 'none';

  // Start loop
  requestAnimationFrame(updateGame);
}

/*********************************
 * Main Loop
 *********************************/
function updateGame() {
  if (gameOver) return;

  ctx.clearRect(0, 0, WIDTH, HEIGHT);

  handleInput();
  spawnAndUpdateCrowns();
  spawnAndUpdateCoins();
  spawnAndUpdateRugs();
  spawnAndUpdateRedHalo();

  if (haloActive) {
    haloTimer--;
    if (haloTimer <= 0) {
      // End halo mode
      score += haloCrownBuffer;
      haloCrownBuffer = 0;
      haloActive = false;
      playerEmoji = EMOJI_PLAYER_NORMAL;
    }
  }

  checkCollisions();

  drawPlayer();
  drawCrowns();
  drawCoins();
  drawRugs();
  drawRedHalo();

  updateUI();
  requestAnimationFrame(updateGame);
}

/*********************************
 * Spawning & Movement
 *********************************/
function handleInput() {
  // Keyboard left/right
  if (keys['ArrowLeft']) {
    player.x -= player.speed;
  }
  if (keys['ArrowRight']) {
    player.x += player.speed;
  }

  // Mobile touch
  if (movingLeft) {
    player.x -= player.speed;
  }
  if (movingRight) {
    player.x += player.speed;
  }

  // Boundaries
  if (player.x < 0) player.x = 0;
  if (player.x + player.width > WIDTH) {
    player.x = WIDTH - player.width;
  }
}

/* CROWNS */
function spawnAndUpdateCrowns() {
  crownSpawnTimer++;
  const currentCrownInterval = (score >= 420) ? crownSpawnInterval * 2 : crownSpawnInterval;
  
  if (crownSpawnTimer >= currentCrownInterval) {
    spawnCrown();
    crownSpawnTimer = 0;
  }

  for (let i = 0; i < crowns.length; i++) {
    let c = crowns[i];
    if (haloActive) {
      pullCrownToPlayer(c);
    } else {
      let baseSpeed = (score >= 420) ? c.speed * 1.8 : c.speed;
      c.y += baseSpeed;
    }
    if (c.y > HEIGHT + c.height) {
      crowns.splice(i, 1);
      i--;
    }
  }
}

function spawnCrown() {
  crowns.push({
    x: Math.random() * (WIDTH - 28),
    y: -40,
    width: 28,
    height: 28,
    speed: 4
  });
}

function pullCrownToPlayer(c) {
  let px = player.x + player.width / 2;
  let py = player.y + player.height / 2;
  let dx = px - c.x;
  let dy = py - c.y;
  let factor = 0.1; 
  c.x += dx * factor;
  c.y += dy * factor;
}

/* COINS */
function spawnAndUpdateCoins() {
  coinSpawnTimer++;
  if (coinSpawnTimer >= coinSpawnInterval) {
    spawnCoin();
    coinSpawnTimer = 0;
  }
  for (let i = 0; i < coins.length; i++) {
    coins[i].y += coins[i].speed;
    if (coins[i].y > HEIGHT + coins[i].height) {
      coins.splice(i, 1);
      i--;
    }
  }
}

function spawnCoin() {
  let rnd = Math.floor(Math.random() * EMOJI_COINS.length);
  coins.push({
    x: Math.random() * (WIDTH - 28),
    y: -32,
    width: 28,
    height: 28,
    speed: 6 + Math.random(),
    emoji: EMOJI_COINS[rnd]
  });
}

/* RUGS */
function spawnAndUpdateRugs() {
  rugSpawnTimer++;
  const currentRugInterval = (score >= 420) ? rugSpawnInterval / 2 : rugSpawnInterval;

  if (rugSpawnTimer >= currentRugInterval) {
    spawnRug();
    rugSpawnTimer = 0;
  }
  for (let i = 0; i < rugs.length; i++) {
    let r = rugs[i];
    r.y += r.speed;
    if (r.y > HEIGHT + r.height) {
      rugs.splice(i, 1);
      i--;
      rugsAvoidedCount++;
      if (rugsAvoidedCount >= 69) {
        spawnRedHalo();
        rugsAvoidedCount = 0;
      }
    }
  }
}

function spawnRug() {
  rugs.push({
    x: Math.random() * (WIDTH - 44),
    y: -44,
    width: 44,
    height: 44,
    speed: 4
  });
}

/*********************************
 * RED HALO
 *********************************/
function spawnAndUpdateRedHalo() {
  if (redHalo) {
    redHalo.y += redHalo.speed;
    redHalo.angle += 0.1;
    redHalo.x += Math.sin(redHalo.angle) * redHalo.amplitude;
    if (redHalo.y > HEIGHT + redHalo.height) {
      redHalo = null;
    }
  }
}

function spawnRedHalo() {
  if (!redHalo) {
    redHalo = {
      x: Math.random() * (WIDTH - 28),
      y: -32,
      width: 28,
      height: 28,
      speed: 4,
      angle: 0,
      amplitude: 2.5
    };
  }
}

function activateHaloMode() {
  haloActive = true;
  haloTimer = 120; // ~2 seconds
  haloCrownBuffer = 0;
  playerEmoji = EMOJI_PLAYER_HALO;
}

/*********************************
 * Collisions
 *********************************/
function checkCollisions() {
  // Player vs Crowns
  for (let i = 0; i < crowns.length; i++) {
    if (rectCollision(player, crowns[i])) {
      if (haloActive) {
        haloCrownBuffer++;
      } else {
        score++;
        crownsCollected++;
        if (crownsCollected % 69 === 0) {
          player.lives++;
        }
      }
      crowns.splice(i, 1);
      i--;
    }
  }

  // Player vs Coins => reset score
  for (let i = 0; i < coins.length; i++) {
    if (rectCollision(player, coins[i])) {
      score = 0;
      coins.splice(i, 1);
      i--;
    }
  }

  // Player vs Rug => reset score, lose life
  for (let i = 0; i < rugs.length; i++) {
    if (rectCollision(player, rugs[i])) {
      score = 0;
      player.lives--;
      rugsAvoidedCount = 0;
      rugs.splice(i, 1);
      i--;
      if (player.lives <= 0) {
        gameOverSequence();
        return;
      }
    }
  }

  // Player vs Red Halo => halo mode
  if (redHalo && rectCollision(player, redHalo)) {
    redHalo = null;
    activateHaloMode();
  }
}

/*********************************
 * Drawing
 *********************************/
function drawPlayer() {
  drawEmoji(playerEmoji, player.x, player.y, player.width);
}

function drawCrowns() {
  crowns.forEach(c => {
    drawEmoji(EMOJI_CROWN, c.x, c.y, c.width);
  });
}

function drawCoins() {
  coins.forEach(coin => {
    drawEmoji(coin.emoji, coin.x, coin.y, coin.width);
  });
}

function drawRugs() {
  rugs.forEach(rug => {
    drawEmoji(EMOJI_RUG, rug.x, rug.y, rug.width);
  });
}

function drawRedHalo() {
  if (redHalo) {
    drawEmoji(EMOJI_RED_HALO, redHalo.x, redHalo.y, redHalo.width);
  }
}

/**
 * Draws a single emoji on canvas at (x,y).
 * We treat (x,y) as the top-left corner by using textBaseline = "top".
 */
function drawEmoji(emoji, x, y, size) {
  ctx.font = `${size}px sans-serif`;
  ctx.textBaseline = "top"; 
  ctx.fillText(emoji, x, y);
}

/*********************************
 * Utility & UI
 *********************************/
function rectCollision(a, b) {
  return (
    a.x < b.x + b.width &&
    a.x + a.width > b.x &&
    a.y < b.y + b.height &&
    a.y + a.height > b.y
  );
}

function updateUI() {
  document.getElementById('livesDisplay').textContent = 'Lives: ' + player.lives;
  document.getElementById('scoreDisplay').textContent = 'Score: ' + score;
}

function gameOverSequence() {
  gameOver = true;
  if (score > highScore) {
    highScore = score;
    localStorage.setItem('emojiCollectorHighScore', highScore);
  }
  document.getElementById('finalScoreValue').textContent = score;
  document.getElementById('highScoreValue').textContent = highScore;

  document.getElementById('gameOverScreen').style.display = 'block';
  document.getElementById('gameOverMessage').textContent = 'RUGGED AGAIN';
}

function restartGame() {
  // Show instructions again or just reset
  document.getElementById('gameOverScreen').style.display = 'none';
  startGame();
}
</script>

</body>
</html>
