<!DOCTYPE html>
<html lang="en">
<head>
  <!-- ... (keep original head content unchanged) ... -->
</head>
<body>

<div id="gameContainer">
  <!-- ... (keep original HTML structure unchanged) ... -->
</div>

<script>
// Cache DOM elements
const livesDisplay = document.getElementById('livesDisplay');
const scoreDisplay = document.getElementById('scoreDisplay');
const gameOverScreen = document.getElementById('gameOverScreen');
const shareXLink = document.getElementById('shareXLink');

/*******************************************************
 * 1) Dev Tools Deterrent (basic)
 *******************************************************/
document.addEventListener('contextmenu', e => e.preventDefault());
document.onkeydown = function(e) {
  if (e.key === 'F12' || (e.ctrlKey && e.shiftKey && e.key === 'I')) {
    e.preventDefault();
  }
};

/*******************************************************
 * 2) Self-Integrity Check (basic deterrent)
 *******************************************************/
function selfIntegrityCheck() {
  const checkStr = selfIntegrityCheck.toString();
  if (checkStr.length < 100 || checkStr.includes('debugger')) {
    setScore(0);
    endGame();
  }
}
setInterval(selfIntegrityCheck, 15000);

/*******************************************************
 * 3) Secure Score Storage
 *******************************************************/
function encodeVal(val, secret = "PUMPK1NG_S3CR3T") {
  const combined = secret + val.toString().split('').reverse().join('');
  return btoa(combined);
}

function decodeVal(encoded, secret = "PUMPK1NG_S3CR3T") {
  try {
    const raw = atob(encoded);
    return raw.startsWith(secret) ? parseFloat(raw.slice(secret.length).split('').reverse().join('')) : 0;
  } catch(e) {
    return 0;
  }
}

let _encScore = encodeVal(0);
function getScore() { return decodeVal(_encScore); }
function setScore(newVal) { _encScore = encodeVal(newVal); }

/*******************************************************
 * 4) Rate Limiting
 *******************************************************/
let eventCount = 0;
let startTime = Date.now();

function trackEvent() {
  eventCount++;
  const elapsed = (Date.now() - startTime)/1000;
  if (eventCount / elapsed > 100) { // 100 events/sec threshold
    setScore(0);
    endGame();
  }
}

/*******************************************************
 * 5) Game Mechanics
 *******************************************************/
// ... (keep original game variable declarations) ...

// Optimized collision detection
function rectCollision(a, b) {
  return !(a.x >= b.x + b.width || 
           a.x + a.width <= b.x || 
           a.y >= b.y + b.height || 
           a.y + a.height <= b.y);
}

// Optimized object pooling
const objectPool = {
  crowns: [],
  coins: [],
  rugs: [],
  getCrown: function() {
    return this.crowns.pop() || { 
      x: 0, y: -40, width: 28, height: 28, speed: 4 
    };
  },
  // Similar methods for coins/rugs...
};

// Optimized draw operations
const emojiCache = new Map();
function drawEmoji(emoji, x, y, size) {
  if (!emojiCache.has(size)) {
    ctx.font = `${size}px sans-serif`;
    emojiCache.set(size, ctx.font);
  }
  ctx.font = emojiCache.get(size);
  ctx.fillText(emoji, x, y);
}

// Mobile control improvements
let touchId = null;
function handleTouchStart(e) {
  e.preventDefault();
  if (!touchId) {
    touchId = e.changedTouches[0].identifier;
    const halfWidth = window.innerWidth / 2;
    movingLeft = e.changedTouches[0].clientX < halfWidth;
    movingRight = !movingLeft;
  }
}

function handleTouchEnd(e) {
  e.preventDefault();
  for (let touch of e.changedTouches) {
    if (touch.identifier === touchId) {
      touchId = null;
      movingLeft = movingRight = false;
    }
  }
}

document.getElementById('mobileControls').addEventListener('touchstart', handleTouchStart, {passive: false});
document.getElementById('mobileControls').addEventListener('touchend', handleTouchEnd, {passive: false});
document.getElementById('mobileControls').addEventListener('touchcancel', handleTouchEnd, {passive: false});

// Optimized game loop
let lastFrame = 0;
function updateGame(timestamp) {
  if (gameOver) return;
  
  const deltaTime = timestamp - lastFrame;
  lastFrame = timestamp;

  // Update game state with deltaTime
  crownSpawnTimer += deltaTime;
  coinSpawnTimer += deltaTime;
  rugSpawnTimer += deltaTime;

  // ... (rest of game logic with deltaTime adjustments) ...

  requestAnimationFrame(updateGame);
}

// Share link handling
shareXLink.addEventListener('click', function(e) {
  e.preventDefault();
  const finalScore = Math.floor(getScore());
  const tweetText = `I scored ${finalScore} in PumpKing! ðŸŽƒðŸ‘‘ #CrownCollector`;
  window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(tweetText)}`, '_blank');
});

// ... (rest of the game logic with optimized DOM access and collision detection) ...
</script>
</body>
</html>
