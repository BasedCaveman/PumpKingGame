<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PumpKing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>
  <style>
    /* Basic Reset & Layout */
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      font-family: sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }

    /* 9:16 aspect ratio container, up to 666px wide */
    #gameContainer {
      position: relative;
      width: min(100vw, 666px);
      max-height: 100vh;
      aspect-ratio: 9 / 16;
      background: #111;
      border: 2px solid #fff;
      overflow: hidden; 
    }

    /* Canvas scaled to fill container, logic is 666x1184 */
    #gameCanvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    /* Overlays */
    .overlay {
      position: absolute;
      top: 0; 
      left: 0;
      width: 100%;
      height: 100%;
      color: #fff;
      text-align: center;
    }

    #overlay {
      pointer-events: none;
      z-index: 2;
    }
    #livesDisplay, #scoreDisplay {
      margin: 0.5em;
      font-size: 20px;
      text-shadow: 1px 1px 0 #000;
    }

    /* Initial instructions */
    #instructionsOverlay {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(0,0,0,0.8);
      z-index: 999;
    }
    #instructionsOverlay button {
      margin-top: 1em;
      padding: 0.5em 1em;
      font-size: 16px;
      cursor: pointer;
    }

    /* Game Over Screen */
    #gameOverScreen {
      display: none;
      background: rgba(0, 0, 0, 0.8);
      z-index: 10;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-size: 24px;
      padding: 1em;
      box-sizing: border-box;
    }
    #gameOverMessage {
      margin-bottom: 1em;
    }
    /* "Share on X" link styling */
    #shareXLink {
      margin-top: 1em;
      background: #1d9bf0; /* Twitter Blue */
      color: #fff;
      text-decoration: none;
      font-size: 18px;
      padding: 0.5em 1em;
      border-radius: 6px;
    }

    /* Mobile Controls: two clickable halves at bottom */
    #mobileControls {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 40%; 
      z-index: 5;
      display: flex;
    }
    .control-half {
      width: 50%;
      height: 100%;
      background: rgba(0,0,0,0.1);
    }
    .control-half:active {
      background: rgba(0,0,0,0.2);
    }
  </style>
</head>
<body>

<div id="gameContainer">

  <!-- Instruction Overlay -->
  <div id="instructionsOverlay" class="overlay">
    <h1>Crown Collector</h1>
    <p style="max-width: 80%; margin: 0 auto;">
      - You start with <strong>1 life</strong>.<br>
      - Crown (ðŸ‘‘) => +6.9 points<br>
      - Coin => score=0; after 6 hits => lose 1 life<br>
      - Rug => lose 1 life, if not lethal => score=0<br>
      - After <strong>420</strong> points => triple coins & rugs spawn; 
        double crowns spawn & speed.<br>
      - Avoid <strong>30</strong> rugs => Red Halo spawns<br>
      - Final scoreboard shows your <strong>peak score</strong> & final score<br>
    </p>
    <button id="startGameBtn">Start Game</button>
  </div>

  <!-- The game canvas (666Ã—1184) -->
  <canvas id="gameCanvas" width="666" height="1184"></canvas>

  <!-- Score overlay at top -->
  <div id="overlay" class="overlay" style="z-index:3;">
    <div id="livesDisplay">Lives: 1</div>
    <div id="scoreDisplay">Score: 0</div>
  </div>

  <!-- Game Over Screen -->
  <div id="gameOverScreen" class="overlay" style="display:flex;">
    <div id="gameOverMessage">RUGGED AGAIN</div>
    <div>
      Final Score: <span id="finalScoreValue">0</span><br>
      Peak Score: <span id="peakScoreValue">0</span>
    </div>
    <div id="endStats" style="margin-top:1em; font-size:16px;"></div>

    <!-- "Share on X" link -->
    <a id="shareXLink" href="#" target="_blank">Share on X</a>

    <div style="margin-top:1em;">Press SPACE or tap to play again</div>
  </div>

  <!-- Mobile Controls -->
  <div id="mobileControls">
    <div id="leftHalf" class="control-half"></div>
    <div id="rightHalf" class="control-half"></div>
  </div>

</div>

<script>

/*******************************************************
 * 1) Attempt to Disable Dev Tools (easily bypassable)
 *******************************************************/
document.addEventListener('contextmenu',(e)=>e.preventDefault());
document.onkeydown = function(e) {
  if (e.key === 'F12' || (e.ctrlKey && e.shiftKey && e.key === 'I')) {
    e.preventDefault();
    alert("DevTools disabled!");
  }
};

/*******************************************************
 * 2) Obfuscation & Checking Self-Integrity
 *    (Trivial example only â€“ in production,
 *     you'd do minification/obfuscation.)
 *******************************************************/
function selfIntegrityCheck() {
  if (selfIntegrityCheck.toString().length < 100) {
    alert("Code tampering detected!");
    setScore(0); // or end the game, etc.
  }
}
// Call this periodically
setInterval(selfIntegrityCheck, 10000);

/*******************************************************
 * 3) Encoded Score Storage
 *******************************************************/
function encodeVal(val, secret="SALT123") {
  const combined = secret + val.toString().split('').reverse().join('');
  return btoa(combined);
}
function decodeVal(encoded, secret="SALT123") {
  try {
    const raw = atob(encoded);
    if (!raw.startsWith(secret)) return 0; 
    const rev = raw.slice(secret.length).split('').reverse().join('');
    return parseFloat(rev);
  } catch(e) {
    return 0;
  }
}
let _encScore = encodeVal(0);
function getScore(){
  return decodeVal(_encScore);
}
function setScore(newVal){
  _encScore = encodeVal(newVal);
}

/*******************************************************
 * 4) Rate/Time Checks
 *******************************************************/
let startTime = Date.now();
let eventCount = 0;
function trackEvent() {
  eventCount++;
  const elapsed = (Date.now() - startTime)/1000;
  // If we exceed some threshold => suspicious
  if (eventCount / elapsed > 50) {
    alert("Suspicious activity rate!");
    setScore(0);
  }
}

/*******************************************************
 * 5) Crown Collector Mechanics
 *******************************************************/
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const WIDTH = canvas.width;  
const HEIGHT = canvas.height;

let player = {
  x: WIDTH / 2 - 24,
  y: HEIGHT - 70,
  width: 48,
  height: 48,
  speed: 6,
  lives: 1
};

let score = 0, peakScore = 0;
let crownsCollected = 0, rugsAvoidedCount = 0;
let coinHits = 0, redHaloCollected = 0, gameOver = false;

let baseCrownSpawnInterval = 30;
let baseCoinSpawnInterval  = 42;
let baseRugSpawnInterval   = 69;

let crownSpawnInterval = baseCrownSpawnInterval;
let coinSpawnInterval  = baseCoinSpawnInterval;
let rugSpawnInterval   = baseRugSpawnInterval;

let crownSpawnTimer=0, coinSpawnTimer=0, rugSpawnTimer=0;

let difficultyUp = false;
let haloActive = false;
let haloTimer = 0;
let haloCrownBuffer = 0;

const EMOJI_PLAYER_NORMAL = "ðŸŽƒ";
const EMOJI_PLAYER_HALO   = "ðŸ’€â­•";
const EMOJI_COIN_VARIANTS = ["â™Ž","ðŸ‡·ðŸ‡º","ðŸ’¸"];
const EMOJI_RUG           = "ðŸ§»";
const EMOJI_RED_HALO      = "â­•";

let playerEmoji = EMOJI_PLAYER_NORMAL;

// Controls
let keys = {};
let movingLeft = false, movingRight = false;

window.addEventListener('keydown',(e)=>{
  if(gameOver && e.code==='Space'){ restartGame(); }
  keys[e.code]=true;
});
window.addEventListener('keyup',(e)=>{
  keys[e.code]=false;
});

const leftHalf=document.getElementById('leftHalf');
leftHalf.addEventListener('touchstart',(e)=>{ e.preventDefault(); movingLeft=true; });
leftHalf.addEventListener('touchend',(e)=>{ e.preventDefault(); movingLeft=false; });

const rightHalf=document.getElementById('rightHalf');
rightHalf.addEventListener('touchstart',(e)=>{ e.preventDefault(); movingRight=true; });
rightHalf.addEventListener('touchend',(e)=>{ e.preventDefault(); movingRight=false; });

const instructionsOverlay=document.getElementById('instructionsOverlay');
const startGameBtn=document.getElementById('startGameBtn');
startGameBtn.addEventListener('click',()=>{
  instructionsOverlay.style.display='none';
  startGame();
});

function startGame(){
  gameOver=false;
  player.lives=1;
  player.x=WIDTH/2-24;
  setScore(0); // Using encoded
  peakScore=0;
  crownsCollected=0;
  rugsAvoidedCount=0;
  coinHits=0;
  redHaloCollected=0;
  difficultyUp=false;

  crownSpawnInterval=baseCrownSpawnInterval;
  coinSpawnInterval=baseCoinSpawnInterval;
  rugSpawnInterval=baseRugSpawnInterval;

  crowns=[]; coins=[]; rugs=[]; redHalo=null;
  haloActive=false; haloTimer=0; haloCrownBuffer=0;
  playerEmoji=EMOJI_PLAYER_NORMAL;

  document.getElementById('gameOverScreen').style.display='none';
  requestAnimationFrame(updateGame);
}

function updateGame(){
  if(gameOver)return;

  ctx.clearRect(0,0,WIDTH,HEIGHT);

  handleInput();
  checkDifficulty();

  spawnAndUpdateCrowns();
  spawnAndUpdateCoins();
  spawnAndUpdateRugs();
  spawnAndUpdateRedHalo();

  if(haloActive){
    haloTimer--;
    if(haloTimer<=0){
      let sc=getScore();
      sc+=haloCrownBuffer;
      setScore(sc);
      haloCrownBuffer=0;
      haloActive=false;
      playerEmoji=EMOJI_PLAYER_NORMAL;
      updatePeakScore();
    }
  }

  checkCollisions();
  drawEverything();
  updateUI();

  requestAnimationFrame(updateGame);
}

// Difficulty after 420
function checkDifficulty(){
  let sc=getScore();
  if(!difficultyUp && sc>=420){
    difficultyUp=true;
    coinSpawnInterval/=3;
    rugSpawnInterval/=3;
    crownSpawnInterval/=2;
  }
}

function handleInput(){
  if(keys['ArrowLeft']) player.x-=player.speed;
  if(keys['ArrowRight'])player.x+=player.speed;
  if(movingLeft) player.x-=player.speed;
  if(movingRight)player.x+=player.speed;

  if(player.x<0)player.x=0;
  if(player.x+player.width>WIDTH)player.x=WIDTH-player.width;
}

/****** Crowns ******/
let crowns=[];
function spawnAndUpdateCrowns(){
  crownSpawnTimer++;
  if(crownSpawnTimer>=crownSpawnInterval){
    spawnCrown(); 
    crownSpawnTimer=0;
  }
  for(let i=0;i<crowns.length;i++){
    let c=crowns[i];
    if(haloActive){
      pullCrownToPlayer(c);
    } else {
      let speedFactor=(difficultyUp)? c.speed*2 : c.speed;
      c.y+=speedFactor;
    }
    if(c.y>HEIGHT+c.height){
      crowns.splice(i,1);
      i--;
    }
  }
}
function spawnCrown(){
  let baseSpeed=(difficultyUp?8:4);
  crowns.push({ x:Math.random()*(WIDTH-28), y:-40, width:28, height:28, speed:baseSpeed });
}
function pullCrownToPlayer(c){
  let px=player.x+player.width/2;
  let py=player.y+player.height/2;
  let dx=px-c.x; 
  let dy=py-c.y;
  c.x+=dx*0.1; 
  c.y+=dy*0.1;
}

/****** Coins ******/
let coins=[];
function spawnAndUpdateCoins(){
  coinSpawnTimer++;
  if(coinSpawnTimer>=coinSpawnInterval){
    spawnCoin();
    coinSpawnTimer=0;
  }
  for(let i=0;i<coins.length;i++){
    coins[i].y+=coins[i].speed;
    if(coins[i].y>HEIGHT+coins[i].height){
      coins.splice(i,1);
      i--;
    }
  }
}
function spawnCoin(){
  let rnd=Math.floor(Math.random()*EMOJI_COIN_VARIANTS.length);
  coins.push({
    x:Math.random()*(WIDTH-28),
    y:-32,
    width:28,
    height:28,
    speed:6+Math.random(),
    emoji:EMOJI_COIN_VARIANTS[rnd]
  });
}

/****** Rugs ******/
let rugs=[];
function spawnAndUpdateRugs(){
  rugSpawnTimer++;
  if(rugSpawnTimer>=rugSpawnInterval){
    spawnRug();
    rugSpawnTimer=0;
  }
  for(let i=0;i<rugs.length;i++){
    let r=rugs[i];
    r.y+=r.speed;
    if(r.y>HEIGHT+r.height){
      rugs.splice(i,1);
      i--;
      rugsAvoidedCount++;
      if(rugsAvoidedCount>=30){
        spawnRedHalo();
        rugsAvoidedCount=0;
      }
    }
  }
}
function spawnRug(){
  rugs.push({
    x:Math.random()*(WIDTH-44),
    y:-44,
    width:44,
    height:44,
    speed:6
  });
}

/****** Red Halo ******/
let redHalo=null;
function spawnAndUpdateRedHalo(){
  if(redHalo){
    redHalo.y+=redHalo.speed;
    redHalo.angle=(redHalo.angle||0)+0.1;
    redHalo.x+=Math.sin(redHalo.angle)*(redHalo.amplitude||2.5);
    if(redHalo.y>HEIGHT+redHalo.height){
      redHalo=null;
    }
  }
}
function spawnRedHalo(){
  if(!redHalo){
    redHalo={
      x:Math.random()*(WIDTH-33),
      y:-32,
      width:28,
      height:28,
      speed:4,
      angle:0,
      amplitude:2.5
    };
  }
}
function activateHaloMode(){
  haloActive=true;
  haloTimer=120; 
  haloCrownBuffer=0;
  playerEmoji=EMOJI_PLAYER_HALO;
  redHaloCollected++;
}

/****** Collisions ******/
function rectCollision(a,b){
  return(
    a.x< b.x+b.width &&
    a.x+a.width> b.x &&
    a.y< b.y+b.height &&
    a.y+a.height> b.y
  );
}
function checkCollisions(){
  // Crowns => +6.9
  for(let i=0;i<crowns.length;i++){
    if(rectCollision(player,crowns[i])){
      trackEvent(); 
      if(haloActive){
        haloCrownBuffer+=6.9;
      } else {
        let sc=getScore(); 
        sc+=6.9; 
        setScore(sc);
        updatePeakScore();
      }
      crownsCollected++;
      crowns.splice(i,1); 
      i--;
    }
  }
  // Coins => score=0, after 6 => lose life
  for(let i=0;i<coins.length;i++){
    if(rectCollision(player,coins[i])){
      trackEvent(); 
      setScore(0);
      coinHits++;
      coins.splice(i,1);
      i--;

      if(coinHits>=6){
        coinHits=0;
        player.lives--;
        if(player.lives<=0){
          endGame();
          return;
        }
      }
    }
  }
  // Rugs => lose 1 life, if not lethal => score=0
  for(let i=0;i<rugs.length;i++){
    if(rectCollision(player,rugs[i])){
      trackEvent(); 
      if(player.lives>1){
        setScore(0);
      }
      player.lives--;
      rugs.splice(i,1);
      i--;
      if(player.lives<=0){
        endGame();
        return;
      }
    }
  }
  // Red Halo
  if(redHalo && rectCollision(player,redHalo)){
    redHalo=null;
    activateHaloMode();
  }
}

/*******************************************************
 * 6) Rate-based checks â€“ each â€œscoreâ€ event calls trackEvent()
 *   see above (in checkCollisions => trackEvent())
 *******************************************************/
function trackEvent(){
  eventCount++;
  const elapsedSec=(Date.now()-startTime)/1000;
  // if too many events => suspicious, etc.
}

/*******************************************************
 * Score Helpers
 *******************************************************/
function getScoreDecoded(){
  return decodeVal(_encScore);
}
function updatePeakScore(){
  let sc=getScoreDecoded();
  if(sc>peakScore) peakScore=sc;
}

/*******************************************************
 * Final Render / UI
 *******************************************************/
function drawEverything(){
  // draw the player
  drawEmoji(playerEmoji,player.x,player.y,player.width);
  // draw crowns
  crowns.forEach(c=>drawEmoji("ðŸ‘‘",c.x,c.y,c.width));
  // draw coins
  coins.forEach(coin=>drawEmoji(coin.emoji,coin.x,coin.y,coin.width));
  // draw rugs
  rugs.forEach(r=>drawEmoji("ðŸ§»",r.x,r.y,r.width));
  // red halo
  if(redHalo) drawEmoji("â­•",redHalo.x,redHalo.y,redHalo.width);
}
function drawEmoji(emoji,x,y,size){
  ctx.font=`${size}px sans-serif`;
  ctx.textBaseline="top";
  ctx.fillText(emoji,x,y);
}

function updateUI(){
  document.getElementById('livesDisplay').textContent="Lives: "+player.lives;
  document.getElementById('scoreDisplay').textContent="Score: "+Math.floor(getScoreDecoded());
}

/*******************************************************
 * End Game
 *******************************************************/
function endGame(){
  gameOver=true;
  updatePeakScore(); 
  document.getElementById('finalScoreValue').textContent=Math.floor(getScoreDecoded());
  document.getElementById('peakScoreValue').textContent=Math.floor(peakScore);

  const statsText=`
    Crowns Collected: ${crownsCollected}<br>
    Rugs Avoided: ${rugsAvoidedCount}<br>
    Red Halos Collected: ${redHaloCollected}
  `;
  document.getElementById('endStats').innerHTML=statsText;

  // Build "Share on X"
  let finalScore=Math.floor(getScoreDecoded());
  let peak=Math.floor(peakScore);
  let tweetText=`I just played PumpKing!
Final: ${finalScore}, Peak: ${peak}
Crowns: ${crownsCollected}, Avoided Rugs: ${rugsAvoidedCount}, Halos: ${redHaloCollected}.
Try it out! #CrownCollectorGame`;
  let shareUrl=`https://twitter.com/intent/tweet?text=${encodeURIComponent(tweetText)}`;
  document.getElementById('shareXLink').href=shareUrl;

  document.getElementById('gameOverScreen').style.display='flex';
}

function restartGame(){
  document.getElementById('gameOverScreen').style.display='none';
  startGame();
}

/*******************************************************
 * 7) Freed dev code â€“ e.g. tracking event rate
 *******************************************************/
let eventCount=0;
let startTime=Date.now();

</script>
</body>
</html>
